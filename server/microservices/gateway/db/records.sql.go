// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: records.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createRecord = `-- name: CreateRecord :one
INSERT INTO records (
  organization_id,
  user_id,
  record,
  scan_title
) VALUES  (
  $1, $2, $3, $4
) RETURNING id, organization_id, user_id, record, scan_title, created_at, updated_at
`

type CreateRecordParams struct {
	OrganizationID string `db:"organization_id" json:"organization_id"`
	UserID         string `db:"user_id" json:"user_id"`
	Record         string `db:"record" json:"record"`
	ScanTitle      string `db:"scan_title" json:"scan_title"`
}

func (q *Queries) CreateRecord(ctx context.Context, arg CreateRecordParams) (*Record, error) {
	row := q.db.QueryRow(ctx, createRecord,
		arg.OrganizationID,
		arg.UserID,
		arg.Record,
		arg.ScanTitle,
	)
	var i Record
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.UserID,
		&i.Record,
		&i.ScanTitle,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getRecord = `-- name: GetRecord :one
SELECT id, organization_id, user_id, record, scan_title, created_at, updated_at FROM records where id = $1
`

func (q *Queries) GetRecord(ctx context.Context, id string) (*Record, error) {
	row := q.db.QueryRow(ctx, getRecord, id)
	var i Record
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.UserID,
		&i.Record,
		&i.ScanTitle,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getRecords = `-- name: GetRecords :many
SELECT id, organization_id, user_id, record, scan_title, created_at, updated_at FROM records where organization_id = $1
LIMIT 50
`

func (q *Queries) GetRecords(ctx context.Context, organizationID string) ([]*Record, error) {
	rows, err := q.db.Query(ctx, getRecords, organizationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Record
	for rows.Next() {
		var i Record
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.UserID,
			&i.Record,
			&i.ScanTitle,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecordsByUser = `-- name: GetRecordsByUser :many
SELECT id, organization_id, user_id, record, scan_title, created_at, updated_at FROM records where user_id = $1
ORDER BY created_at DESC
LIMIT 10
`

func (q *Queries) GetRecordsByUser(ctx context.Context, userID string) ([]*Record, error) {
	rows, err := q.db.Query(ctx, getRecordsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Record
	for rows.Next() {
		var i Record
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.UserID,
			&i.Record,
			&i.ScanTitle,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecordsByUserAndScanTitle = `-- name: GetRecordsByUserAndScanTitle :many
SELECT id, organization_id, user_id, record, scan_title, created_at, updated_at FROM records where user_id = $1 and scan_title ILIKE $2
ORDER BY created_at DESC
LIMIT 10
`

type GetRecordsByUserAndScanTitleParams struct {
	UserID    string `db:"user_id" json:"user_id"`
	ScanTitle string `db:"scan_title" json:"scan_title"`
}

func (q *Queries) GetRecordsByUserAndScanTitle(ctx context.Context, arg GetRecordsByUserAndScanTitleParams) ([]*Record, error) {
	rows, err := q.db.Query(ctx, getRecordsByUserAndScanTitle, arg.UserID, arg.ScanTitle)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Record
	for rows.Next() {
		var i Record
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.UserID,
			&i.Record,
			&i.ScanTitle,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchRecordByNin = `-- name: SearchRecordByNin :many
SELECT records.id, organization_id, user_id, record, scan_title, records.created_at, records.updated_at, users.id, email, nin, password, user_type, address, contact, users.created_at, users.updated_at FROM public.records JOIN public.users ON users.nin = $1
`

type SearchRecordByNinRow struct {
	ID             string             `db:"id" json:"id"`
	OrganizationID string             `db:"organization_id" json:"organization_id"`
	UserID         string             `db:"user_id" json:"user_id"`
	Record         string             `db:"record" json:"record"`
	ScanTitle      string             `db:"scan_title" json:"scan_title"`
	CreatedAt      pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	ID_2           string             `db:"id_2" json:"id_2"`
	Email          pgtype.Text        `db:"email" json:"email"`
	Nin            pgtype.Text        `db:"nin" json:"nin"`
	Password       string             `db:"password" json:"password"`
	UserType       UserEnum           `db:"user_type" json:"user_type"`
	Address        []byte             `db:"address" json:"address"`
	Contact        []byte             `db:"contact" json:"contact"`
	CreatedAt_2    pgtype.Timestamptz `db:"created_at_2" json:"created_at_2"`
	UpdatedAt_2    pgtype.Timestamptz `db:"updated_at_2" json:"updated_at_2"`
}

func (q *Queries) SearchRecordByNin(ctx context.Context, nin pgtype.Text) ([]*SearchRecordByNinRow, error) {
	rows, err := q.db.Query(ctx, searchRecordByNin, nin)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*SearchRecordByNinRow
	for rows.Next() {
		var i SearchRecordByNinRow
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.UserID,
			&i.Record,
			&i.ScanTitle,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID_2,
			&i.Email,
			&i.Nin,
			&i.Password,
			&i.UserType,
			&i.Address,
			&i.Contact,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchRecordByNinAndScanTitle = `-- name: SearchRecordByNinAndScanTitle :many
SELECT records.id, organization_id, user_id, record, scan_title, records.created_at, records.updated_at, users.id, email, nin, password, user_type, address, contact, users.created_at, users.updated_at FROM records JOIN public.users ON
users.nin = $1 WHERE scan_title ILIKE $2
LIMIT 10
`

type SearchRecordByNinAndScanTitleParams struct {
	Nin       pgtype.Text `db:"nin" json:"nin"`
	ScanTitle string      `db:"scan_title" json:"scan_title"`
}

type SearchRecordByNinAndScanTitleRow struct {
	ID             string             `db:"id" json:"id"`
	OrganizationID string             `db:"organization_id" json:"organization_id"`
	UserID         string             `db:"user_id" json:"user_id"`
	Record         string             `db:"record" json:"record"`
	ScanTitle      string             `db:"scan_title" json:"scan_title"`
	CreatedAt      pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt      pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
	ID_2           string             `db:"id_2" json:"id_2"`
	Email          pgtype.Text        `db:"email" json:"email"`
	Nin            pgtype.Text        `db:"nin" json:"nin"`
	Password       string             `db:"password" json:"password"`
	UserType       UserEnum           `db:"user_type" json:"user_type"`
	Address        []byte             `db:"address" json:"address"`
	Contact        []byte             `db:"contact" json:"contact"`
	CreatedAt_2    pgtype.Timestamptz `db:"created_at_2" json:"created_at_2"`
	UpdatedAt_2    pgtype.Timestamptz `db:"updated_at_2" json:"updated_at_2"`
}

func (q *Queries) SearchRecordByNinAndScanTitle(ctx context.Context, arg SearchRecordByNinAndScanTitleParams) ([]*SearchRecordByNinAndScanTitleRow, error) {
	rows, err := q.db.Query(ctx, searchRecordByNinAndScanTitle, arg.Nin, arg.ScanTitle)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*SearchRecordByNinAndScanTitleRow
	for rows.Next() {
		var i SearchRecordByNinAndScanTitleRow
		if err := rows.Scan(
			&i.ID,
			&i.OrganizationID,
			&i.UserID,
			&i.Record,
			&i.ScanTitle,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ID_2,
			&i.Email,
			&i.Nin,
			&i.Password,
			&i.UserType,
			&i.Address,
			&i.Contact,
			&i.CreatedAt_2,
			&i.UpdatedAt_2,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const uploadRecord = `-- name: UploadRecord :one
INSERT INTO uploads (
  organization_id,
  user_id,
  scan_title
) VALUES  (
  $1, $2, $3
) RETURNING id, organization_id, user_id, scan_title, created_at, updated_at
`

type UploadRecordParams struct {
	OrganizationID string `db:"organization_id" json:"organization_id"`
	UserID         string `db:"user_id" json:"user_id"`
	ScanTitle      string `db:"scan_title" json:"scan_title"`
}

func (q *Queries) UploadRecord(ctx context.Context, arg UploadRecordParams) (*Upload, error) {
	row := q.db.QueryRow(ctx, uploadRecord, arg.OrganizationID, arg.UserID, arg.ScanTitle)
	var i Upload
	err := row.Scan(
		&i.ID,
		&i.OrganizationID,
		&i.UserID,
		&i.ScanTitle,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
