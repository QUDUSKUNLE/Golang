// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: schedule.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createSchedule = `-- name: CreateSchedule :one
INSERT INTO diagnostic_schedules (
  user_id,
  diagnostic_centre_id,
  date,
  time,
  test_type,
  status,
  notes
) VALUES  (
  $1, $2, $3, $4, $5, $6, $7
) RETURNING id, user_id, diagnostic_centre_id, date, time, test_type, status, notes, created_at, updated_at
`

type CreateScheduleParams struct {
	UserID             string             `db:"user_id" json:"user_id"`
	DiagnosticCentreID string             `db:"diagnostic_centre_id" json:"diagnostic_centre_id"`
	Date               pgtype.Timestamptz `db:"date" json:"date"`
	Time               pgtype.Timestamptz `db:"time" json:"time"`
	TestType           ScheduleType       `db:"test_type" json:"test_type"`
	Status             ScheduleStatus     `db:"status" json:"status"`
	Notes              pgtype.Text        `db:"notes" json:"notes"`
}

func (q *Queries) CreateSchedule(ctx context.Context, arg CreateScheduleParams) (*DiagnosticSchedule, error) {
	row := q.db.QueryRow(ctx, createSchedule,
		arg.UserID,
		arg.DiagnosticCentreID,
		arg.Date,
		arg.Time,
		arg.TestType,
		arg.Status,
		arg.Notes,
	)
	var i DiagnosticSchedule
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DiagnosticCentreID,
		&i.Date,
		&i.Time,
		&i.TestType,
		&i.Status,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const deleteSchedule = `-- name: DeleteSchedule :one
DELETE FROM diagnostic_schedules
WHERE id = $1
RETURNING id, user_id, diagnostic_centre_id, date, time, test_type, status, notes, created_at, updated_at
`

func (q *Queries) DeleteSchedule(ctx context.Context, id string) (*DiagnosticSchedule, error) {
	row := q.db.QueryRow(ctx, deleteSchedule, id)
	var i DiagnosticSchedule
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DiagnosticCentreID,
		&i.Date,
		&i.Time,
		&i.TestType,
		&i.Status,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getSchedule = `-- name: GetSchedule :one
SELECT id, user_id, diagnostic_centre_id, date, time, test_type, status, notes, created_at, updated_at FROM diagnostic_schedules WHERE id = $1
`

func (q *Queries) GetSchedule(ctx context.Context, id string) (*DiagnosticSchedule, error) {
	row := q.db.QueryRow(ctx, getSchedule, id)
	var i DiagnosticSchedule
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DiagnosticCentreID,
		&i.Date,
		&i.Time,
		&i.TestType,
		&i.Status,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getSchedules = `-- name: GetSchedules :many
SELECT id, user_id, diagnostic_centre_id, date, time, test_type, status, notes, created_at, updated_at FROM diagnostic_schedules
WHERE user_id = $1
ORDER BY date DESC, time DESC
LIMIT $2 OFFSET $3
`

type GetSchedulesParams struct {
	UserID string `db:"user_id" json:"user_id"`
	Limit  int32  `db:"limit" json:"limit"`
	Offset int32  `db:"offset" json:"offset"`
}

func (q *Queries) GetSchedules(ctx context.Context, arg GetSchedulesParams) ([]*DiagnosticSchedule, error) {
	rows, err := q.db.Query(ctx, getSchedules, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*DiagnosticSchedule
	for rows.Next() {
		var i DiagnosticSchedule
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.DiagnosticCentreID,
			&i.Date,
			&i.Time,
			&i.TestType,
			&i.Status,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSchedulesByCentre = `-- name: GetSchedulesByCentre :many
SELECT id, user_id, diagnostic_centre_id, date, time, test_type, status, notes, created_at, updated_at FROM diagnostic_schedules
WHERE diagnostic_centre_id = $1
ORDER BY date DESC, time DESC
LIMIT $2 OFFSET $3
`

type GetSchedulesByCentreParams struct {
	DiagnosticCentreID string `db:"diagnostic_centre_id" json:"diagnostic_centre_id"`
	Limit              int32  `db:"limit" json:"limit"`
	Offset             int32  `db:"offset" json:"offset"`
}

func (q *Queries) GetSchedulesByCentre(ctx context.Context, arg GetSchedulesByCentreParams) ([]*DiagnosticSchedule, error) {
	rows, err := q.db.Query(ctx, getSchedulesByCentre, arg.DiagnosticCentreID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*DiagnosticSchedule
	for rows.Next() {
		var i DiagnosticSchedule
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.DiagnosticCentreID,
			&i.Date,
			&i.Time,
			&i.TestType,
			&i.Status,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSchedulesByStatus = `-- name: GetSchedulesByStatus :many
SELECT id, user_id, diagnostic_centre_id, date, time, test_type, status, notes, created_at, updated_at FROM diagnostic_schedules
WHERE status = $1
ORDER BY date DESC, time DESC
LIMIT $2 OFFSET $3
`

type GetSchedulesByStatusParams struct {
	Status ScheduleStatus `db:"status" json:"status"`
	Limit  int32          `db:"limit" json:"limit"`
	Offset int32          `db:"offset" json:"offset"`
}

func (q *Queries) GetSchedulesByStatus(ctx context.Context, arg GetSchedulesByStatusParams) ([]*DiagnosticSchedule, error) {
	rows, err := q.db.Query(ctx, getSchedulesByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*DiagnosticSchedule
	for rows.Next() {
		var i DiagnosticSchedule
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.DiagnosticCentreID,
			&i.Date,
			&i.Time,
			&i.TestType,
			&i.Status,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSchedule = `-- name: UpdateSchedule :one
UPDATE diagnostic_schedules
SET
  user_id = COALESCE($1, user_id),
  diagnostic_centre_id = COALESCE($2, diagnostic_centre_id),
  date = COALESCE($3, date),
  time = COALESCE($4, time),
  test_type = COALESCE($5, test_type),
  status = COALESCE($6, status),
  notes = COALESCE($7, notes),
  updated_at = NOW()
WHERE id = $8
RETURNING id, user_id, diagnostic_centre_id, date, time, test_type, status, notes, created_at, updated_at
`

type UpdateScheduleParams struct {
	UserID             string             `db:"user_id" json:"user_id"`
	DiagnosticCentreID string             `db:"diagnostic_centre_id" json:"diagnostic_centre_id"`
	Date               pgtype.Timestamptz `db:"date" json:"date"`
	Time               pgtype.Timestamptz `db:"time" json:"time"`
	TestType           ScheduleType       `db:"test_type" json:"test_type"`
	Status             ScheduleStatus     `db:"status" json:"status"`
	Notes              pgtype.Text        `db:"notes" json:"notes"`
	ID                 string             `db:"id" json:"id"`
}

func (q *Queries) UpdateSchedule(ctx context.Context, arg UpdateScheduleParams) (*DiagnosticSchedule, error) {
	row := q.db.QueryRow(ctx, updateSchedule,
		arg.UserID,
		arg.DiagnosticCentreID,
		arg.Date,
		arg.Time,
		arg.TestType,
		arg.Status,
		arg.Notes,
		arg.ID,
	)
	var i DiagnosticSchedule
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.DiagnosticCentreID,
		&i.Date,
		&i.Time,
		&i.TestType,
		&i.Status,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
